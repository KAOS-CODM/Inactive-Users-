<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Inactive User Tools ‚Äî Standalone</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: Arial, sans-serif; background:#111; color:#eee; padding:20px; }
    h1 { color:#ffcc00; }
    button { padding:10px 16px; font-size:16px; border-radius:6px; cursor:pointer; background:#ffcc00; border:none; font-weight:bold; }
    #debugBox { margin-top:20px; font-family:monospace; font-size:12px; background:#000; color:#0f0; padding:6px; max-height:200px; overflow:auto; }
  </style>
</head>
<body>
  <h1>Inactive User Tools</h1>
  <p>This standalone page will scan Cartel Empire for inactive users. Make sure you are logged in on <a href="https://cartelempire.online" target="_blank">Cartel Empire</a> in the same browser.</p>
  <button id="startBtn">üöÄ Start Inactive Finder</button>
  <div id="debugBox"></div>

  <script>
  (function() {
    'use strict';

    // --- Debug overlay ---
    function logScreen(msg) {
      let box = document.querySelector("#debugBox");
      let line = document.createElement("div");
      line.textContent = msg;
      box.appendChild(line);
      box.scrollTop = box.scrollHeight;
    }

    const batchSize = 5;
    const perRangeCap = 200;

    // --- Helpers ---
    function groupByStats(users) {
      let groups = {"0‚Äì1000": [], "1001‚Äì5000": [], "5001‚Äì10000": [], "10000+": []};
      users.forEach(u => {
        let age = parseInt(u.age || "0");
        if (age <= 1000) groups["0‚Äì1000"].push(u);
        else if (age <= 5000) groups["1001‚Äì5000"].push(u);
        else if (age <= 10000) groups["5001‚Äì10000"].push(u);
        else groups["10000+"].push(u);
      });
      return groups;
    }

    function groupByLevel(users) {
      let map = {};
      users.forEach(u => {
        let lvl = parseInt(u.level || "0");
        if (!map[lvl]) map[lvl] = [];
        map[lvl].push(u);
      });
      let ordered = {};
      Object.keys(map).map(Number).sort((a,b)=>a-b).forEach(lvl=>{
        ordered[lvl] = map[lvl];
      });
      return ordered;
    }

    async function parsePageText(t) {
      let d = new DOMParser().parseFromString(t, "text/html");
      let rows = d.querySelectorAll("#userTable tbody tr"), o = [];
      logScreen("üìÑ Parsed page, rows=" + rows.length);

      rows.forEach(r => {
        let link = r.querySelector("th a.fw-bold");
        let profile = link ? new URL(link.getAttribute("href"), location.origin).href : "#";
        o.push({
          name: link?.textContent.trim() || "",
          profile,
          level: r.querySelector("td:nth-of-type(2)")?.textContent.trim() || "",
          age: r.querySelector("td:nth-of-type(3) span")?.textContent.trim() || "0",
          cartel: r.querySelector("td:nth-of-type(4) a")?.textContent.trim() || "None",
          status: r.querySelector("td:nth-of-type(5)")?.textContent.trim() || "",
          activity: r.querySelector("th svg title")?.textContent.trim() || ""
        });
      });
      return o;
    }

    async function fetchPage(p) {
      try {
        logScreen("üåê Fetching page " + p);
        let res = await fetch(`https://cartelempire.online/Search/Users?q=&p=${p}`, {credentials:"include"});
        return await parsePageText(await res.text());
      } catch(e) {
        logScreen("‚ùå Fetch failed p" + p + ": " + e.message);
        return [];
      }
    }

    async function getMaxPages() {
      try {
        let res = await fetch(`https://cartelempire.online/Search/Users?q=&p=1`, { credentials: "include" });
        let text = await res.text();
        let d = new DOMParser().parseFromString(text, "text/html");
        let pl = [...d.querySelectorAll(".pageNav a[data-page]`)].map(a => parseInt(a.getAttribute("data-page")||"1"));
        return pl.length ? Math.max(...pl) : 1;
      } catch(e) {
        logScreen("‚ùå Failed to get max pages: " + e.message);
        return 1;
      }
    }

    async function runInactiveFinder() {
      logScreen("üöÄ Multi-page inactive finder starting‚Ä¶");

      let maxPage = await getMaxPages();
      logScreen("üìë Max pages = " + maxPage);

      let p = prompt(`There are ${maxPage} pages. How many to scan?`, maxPage.toString());
      let pagesToScan = Math.max(1, Math.min(maxPage, parseInt(p) || maxPage));
      logScreen("‚û°Ô∏è Will scan " + pagesToScan + " pages");

      let w = window.open("about:blank", "_blank");
      w.document.write(`<html><head>
        <style>
          body { font-family: Arial, sans-serif; background: #111; color: #eee; padding: 15px; }
          details { margin: 10px 0; border: 1px solid #444; border-radius: 5px; padding: 8px; background: #222; }
          summary { cursor: pointer; font-weight: bold; color: #ffcc00; }
          ul { margin: 5px 0 0 20px; }
          li { margin-bottom: 4px; }
          .show-all { color: #4caf50; cursor: pointer; font-style: italic; margin-top: 6px; display: inline-block; }
        </style>
      </head><body><h1>Loading‚Ä¶</h1></body></html>`);
      w.document.close();

      let currentPage = 1, inactive = [];

      async function processBatch() {
        let promises = [];
        for (let i=0; i<batchSize && currentPage<=pagesToScan; i++, currentPage++) {
          promises.push(fetchPage(currentPage));
        }
        let results = (await Promise.all(promises)).flat();
        let newlyInactive = results.filter(u=>(u.activity||"").toLowerCase().includes("inactive"));
        inactive = inactive.concat(newlyInactive);

        // enforce per-range cap
        let groupedTmp = groupByStats(inactive);
        inactive = Object.values(groupedTmp).flatMap(arr => arr.slice(0, perRangeCap));

        logScreen(`üìä Batch done. Total inactive = ${inactive.length}`);

        let grouped = groupByStats(inactive);

        if (!w.document.querySelector("#inactive-container")) {
          let html = `<div id="inactive-container">
              <h1>Inactive Users ‚Äî grouped</h1>
              <p id="scan-status">Scanned: 0/${pagesToScan} ‚Ä¢ Found: 0</p>`;
          for (const range of Object.keys(grouped)) {
            let rangeId = range.replace(/\W/g,'');
            html += `<details id="range-${rangeId}">
              <summary>Stats ${range} ‚Äî 0 inactive users</summary>
              <div id="levelGroups-${rangeId}"></div>
            </details>`;
          }
          html += `</div>`;
          w.document.body.innerHTML = html;
        }

        w.document.querySelector("#scan-status").textContent =
          `Scanned: ${currentPage-1}/${pagesToScan} ‚Ä¢ Found: ${inactive.length}`;

        for (const range of Object.keys(grouped)) {
          let users = grouped[range];
          let rangeId = range.replace(/\W/g,'');
          let rangeDetails = w.document.querySelector(`#range-${rangeId}`);
          if (!rangeDetails) continue;

          let summary = rangeDetails.querySelector("summary");
          summary.textContent = `Stats ${range} ‚Äî ${users.length} inactive users`;

          let levelsContainer = rangeDetails.querySelector(`#levelGroups-${rangeId}`);
          levelsContainer.innerHTML = "";
          let byLevel = groupByLevel(users);

          for (const lvl of Object.keys(byLevel)) {
            let arr = byLevel[lvl];
            let levelId = `${rangeId}-lvl${lvl}`;

            let details = document.createElement("details");
            details.id = levelId;
            details.innerHTML = `<summary>Level ${lvl} ‚Äî ${arr.length} users</summary>
              <ul>${arr.slice(0,30).map(u=>`<li><a href="${u.profile}" target="_blank">${u.name}</a> ‚Ä¢ Age ${u.age} ‚Ä¢ Cartel: ${u.cartel} ‚Ä¢ ${u.status}</li>`).join("")}</ul>`;
            levelsContainer.appendChild(details);
          }
        }

        if (currentPage<=pagesToScan) setTimeout(processBatch, 500);
      }

      processBatch();
    }

    document.getElementById("startBtn").addEventListener("click", runInactiveFinder);
  })();
  </script>
</body>
</html>
